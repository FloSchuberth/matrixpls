% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matrixpls.R
\name{outer.gsca}
\alias{outer.gsca}
\title{GSCA outer estimation}
\usage{
outer.gsca(S, W, E, W.model, model, ...)
}
\arguments{
\item{S}{Covariance matrix of the data.}

\item{W}{Weight matrix, where the indicators are on colums and composites are on the rows.}

\item{E}{Inner weight matrix. A square matrix of inner estimates between the composites.}

\item{W.model}{A matrix specifying the weight relationships and their starting values.}

\item{model}{A matrixpls model. See \code{\link{matrixpls} for details}}

\item{...}{Other parameters are ignored}
}
\value{
A matrix of unscaled outer weights \code{W} with the same dimesions as \code{W.model}.
}
\description{
This implements the second step of the GSCA algorithm.
}
\details{
The two step GSCA algorithm is designed to minimize.

\code{SS(ZV-ZWA)}

The parameter matrix \code{A} contains all model parameters including
\code{inner}, reflective \code{inner}, and \code{formative}. The weight
matrices \code{V} and \code{W}, which can contain duplicate elements,
contain the indicator weights.

The first step of GSCA estimation method is calculation of regressions
coefficients \code{A} given weights \code{W} and \code{V}. The function
\code{\link{inner.GSCA}} update the part of \code{A} corresponding to 
regressions between the composites, corresponding to \code{E} matrix in 
matrixpls. The regressions between composites and indicators are estimated
in \code{\link{outer.GSCA}}.

This algorithm for estimating the relationships between the composites
is therefore identical to the PLS path weighting scheme with
the exception that correlations are not used for inverse relationships and
there is no falling back to identity scheme for composites that are not
connected to other composites
The second step of GSCA is calculating a new set of weights conditional on
the regression coeffcients \code{A} to minimize the sum of error terms in
the regressions. This step is implemented in \code{\link{outer.GSCA}} after
updating the regresions between indicators and composites.
The implementation of GSCA in matrixpls differs from the Hwang & Takane (2004)
version in that during the first step, only regressions between composites are
estimated. The regressions between composites and indicators are estimated by
the second stage 
the indicators and compositess. Since these covariances need to be calculated in the second step, it is more
efficient to not calculate them during the first step.
}
\examples{
# Run the example from ASGSCA package using GSCA estimation

library(ASGSCA) 
data(GenPhen)
W0 <- matrix(c(rep(1,2),rep(0,8),rep(1,2),rep(0,8),rep(1,3),rep(0,7),rep(1,2)),
             nrow=8,ncol=4)
B0 <- matrix(c(rep(0,8),rep(1,2),rep(0,3),1,rep(0,2)),nrow=4,ncol=4)

# Set seed becayse ASGSCA uses random numbers as starting values 
set.seed(1)

GSCA.res <- GSCA(GenPhen,W0, B0,estim=TRUE,path.test=FALSE, 
                 latent.names=c("Gene1","Gene2",
                                "Clinical pathway 1",
                                "Clinical pathway 2"))

# Setup matrixpls to estimate the same model. Note that GSCA places dependent
# variables on columns but matrixpls uses rows for dependent variables

inner <- t(B0)
formative <- t(W0)
reflective <- matrix(0,8,4)

colnames(formative) <- rownames(reflective) <- names(GenPhen)

colnames(inner) <- rownames(inner) <- 
  rownames(formative) <- colnames(reflective) <-
  c("Gene1","Gene2","Clinical pathway 1","Clinical pathway 2")

model <- list(inner = inner, 
              reflective = reflective,
              formative = formative)

# Estimate using alternating least squares

matrixpls.res1 <- matrixpls(cov(GenPhen),  model,
                            outerEstimators = outer.GSCA,
                            innerEstimator = inner.GSCA)

# Estimate using direct minimization of the estimation criterion
# Set the convergence criterion to be slightly stricter than normally
# to get indentical results

matrixpls.res2 <- matrixpls(cov(GenPhen),  model,
                            weightFunction = weight.optim,
                            optimCriterion = optim.GSCA,
                            control = list(reltol = 1e-12))

# Compare the weights

do.call(cbind,lapply(list(ASGSCA = GSCA.res[["Weight"]],
                          matrixpls_als = t(attr(matrixpls.res1,"W")),
                          matrixpls_optim =t(attr(matrixpls.res2,"W"))),
                     function(W) W[W!=0]))


# Check the criterion function values

optim.GSCA(matrixpls.res1)
optim.GSCA(matrixpls.res2)

}
\references{
Hwang, H., & Takane, Y. (2004). Generalized structured component analysis. \emph{Psychometrika}, 69(1), 81â€“99. doi:10.1007/BF02295841
}
\seealso{
Other GSCA functions: \code{\link{inner.gsca}},
  \code{\link{optim.gsca}}

Other outer estimators: \code{\link{outer.modeA}},
  \code{\link{outer.modeB}}
}

